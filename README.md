# Инструкция

## Локальный запуск (1 опция)
1. Если используете локальные БД и Redis, то проверьте и при необходимости исправьте параметры подключения к ним в application.yaml.
Либо запустите их в докере (предполагаем, что докер установлен на ПК):

**docker run --name shop-v2-db -e POSTGRES_DB=shop_v2_db -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgres -p 5432:5432 -d postgres**

**docker run --name redis-server -it --rm -p 6379:6379 redis:7.4.2-bookworm**

2. Выполните команды для запуска самого приложения (тесты выполнятся автоматически, либо используйте команду **mvn clean test** чтобы запустить только тесты):

**mvn clean package**

После выполнения этой команды по спецификации OpenAPI в папках target у основного модуля также появятся клиентские классы, а у сервиса платежей - серверный код.

**java -jar main_module/target/main_module-0.0.1-SNAPSHOT.jar**

**java -jar payment_service/target/payment_service-0.0.1-SNAPSHOT.jar**

3. Предлагается перейти в админскую панель http://localhost:8080/products/import и загрузить какие-нибудь товары. 
Можно использовать приложенный внутрь проекта файл *init_data.csv* или создать собственный такого же типа.  

## Локальный запуск (2 опция)
1. Подготовьте и запустите БД и Redis любым удобным способом.
2. Выполните команду mvn clean package, чтобы сгенерировался OpenApi код.
3. Настройте конфигурацию для запуска (в любой удобной IDE), запустите приложение.
4. Пользуйтесь приложением (предлагается начать с импорта).

## Запуск в докере
1. Соберите проект (mvn clean package), проверьте что архив в /target называется так же, как в Dockerfile.
2. Используйте docker-compose: docker-compose up --build.
3. Пользуйтесь приложением (предлагается начать с импорта).


# Главная страница - http://localhost:8080/products

# Технические характеристики

1. Приложение написано на Spring Boot.
2. Код приложения хранится в Git-репозитории GitHub.
3. Сборка приложения осуществляется с помощью системы сборки Maven.
4. Код приложения написан на Java 21.
5. Web UI приложения использует проект Spring WebFlux и подключается через соответствующий стартер.
6. Приложение использует Spring Data R2DBC для доступа к данным в БД.
7. База данных приложения - персистентная (PostgreSQL).
8. Приложение можно собрать из исходников и запустить локально.
9. Приложение упаковано в Executable JAR и запускается в Embedded Web Server (по умолчанию Netty).
10. Приложение покрыто тестами (юнит-, интеграционными) с использованием JUnit 5, TestContext Framework, Spring Boot Test и кеширования контекстов.
11. Executable JAR упакован в Docker-контейнер с открытым веб-портом для доступа из браузера (8080, 8081).
12. Приложение состоит из двух сервисов - основной сервис (витрина продуктов) и сервис платежей; общение по REST на реактивном стеке.
13. Написана OpenAPI спецификация интеграции основного приложения и сервиса платежей.
14. На основе разработанной OpenAPI спецификации сгенерированы:
    - клиент основного сервиса для осуществления запросов в сервис платежей;
    - REST-контроллер сервиса платежей для приёма запросов от основного приложения.
15. Основное приложение «Витрина интернет-магазина» и сервис платежей реализованы как подпроекты одного мультипроекта и собираются с помощью системы сборки Maven.
16. В основное приложение «Витрина интернет-магазина» добавлен реактивный стартер проекта Spring Data Redis.

# Функциональность

1. Веб-приложение представляет собой витрину товаров, которые пользователь может положить в корзину и купить.

2. Приложение состоит из шести основных частей (модулей):
    - страницы витрины товаров, доступных для просмотра и покупки;
    - страницы товара;
    - страницы корзины покупателя;
    - страницы всех заказов;
    - страницы заказа;
    - сервиса покупки, который осуществляет REST-запросы в сервис платежей.

3. Страница витрины товаров — это веб-страница (HTML + JavaScript), на которой представлены:
    - список товаров, доступных для заказа (картинка, название, цена, кнопка добавления в корзину/удаления из неё, кнопка изменения количества товара в корзине);
    - список товаров может быть представлен в любом виде (списком, плиткой);
    - есть пагинация (по 10, 20, 50, 100 товаров);
    - сверху строка поиска с фильтрацией по вхождению слова в название товара;
    - сверху доступна сортировка по цене, алфавиту;
    - список товаров берётся из кеша товаров в Redis, а если в кеше данных нет, то загружается в него из БД.

4. При нажатии на товар происходит переход на веб-страницу карточки товара, на которой представлены:
    - название, картинка, описание товара, возможность положить товар в корзину/удалить его, изменить количество в корзине;
    - цена товара;
    - данные о товаре берутся из кеша товаров в Redis, а если в кеше данных нет, то загружаются в него из БД.

5. В правом верхнем углу любой веб-страницы есть кнопка перехода в корзину, которая представляет собой:
    - веб-страницу со списком положенных в неё товаров, их количеством, ценой каждого товара и общей ценой всей корзины;
    - есть возможность удалить товар из корзины, изменить его количество;
    - с кнопкой оформления заказа (доступна, если на балансе в сервисе платежей достаточно средств; если недостаточно или сервис недоступен, то пишется соответствующее сообщение);
    - данные в списке товаров берутся из кеша товаров в Redis, а если в кеше данных нет, то загружаются в него из БД.

6. В правом верхнем углу любой веб-страницы есть кнопка перехода на страницу заказов, которая представляет собой:
    - веб-страницу со списком всех оформленных заказов, суммой каждого заказа и общей суммой всех заказов;
    - при нажатии на заказ появляется веб-страница совершённого заказа.

7. На веб-странице заказа представлен список купленных товаров (картинка, название, цена).

8. При нажатии на кнопку оформления заказа осуществляется REST-запрос в сервис платежей, и при успешной оплате покупки происходят эмуляция оформления заказа и переход на страницу оформленного заказа.

9. Время жизни данных о товарах в кеше берётся: 3 мин.

10. Данные о товарах, которые кешируются в Redis:
    - для карточки товара: идентификатор, картинка, название, цена, описание;
    - для списка товаров: идентификатор, название, описание, цена (они нужны для поиска, сортировки и пейджинга).

11. Есть возможность загрузки списка товаров на витрину товаров (импорт из файла).

12. Сервис платежей представляет собой RESTful-приложение с двумя реактивными HTTP-эндпоинтами:
    - получением баланса на счёте (на ваш выбор логика получения баланса: случайный баланс, загрузка из БД, фиксированный баланс, загрузка из конфига) — если баланс меньше суммы цены товаров в корзине, то кнопка оформления заказа основного приложения недоступна;
    - осуществлением платежа (при нажатии на кнопку оформления заказа происходит запрос на вычитание суммы заказа из баланса) — если оно даёт отрицательный результат, то считается, что оплата заказа не прошла и он не оформляется, и выдаётся соответствующая ошибка.
    
13. Если сервис платежей недоступен, то должна быть недоступна кнопка оформления заказа. В таком случае показывается соответствующее сообщение.

14. Обмен сообщениями с сервисом платежей происходит в формате JSON.
